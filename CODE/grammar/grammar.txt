# do not remove this rule, it's necessary for Earley parser to work
S -> <program>

<program> -> <sentence> | <function> | <sentence> <program> | <function> <program>
<Number> -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
<Numbers> -> <Number><Numbers> | <Number>
<digit> -> <sign><real> | <sign><real><exponent> | <real> | <real><exponent>
<real> -> <Numbers>.<Numbers>| .<Numbers> | <Numbers>. | <Numbers>
<exponent> -> e<sign><Numbers> | E<sign><Numbers> | e<Numbers> | E<Numbers>
<sign> -> + | -
<String> -> "<quotes_String> | '<apostrophe_String>
<quotes_String> -> <symbols>"
<apostrophe_String> -> <symbols>'
<symbols> -> <symbol><symbols> | <symbol>
<symbol> -> \U0000<unicode_four> | \U000<unicode_five> | 0<symbol> | 1<symbol> | 2<symbol> | 3<symbol> | 4<symbol> | 5<symbol> | 6<symbol> | 7<symbol> | 8<symbol> | 9<symbol> | A<symbol> | B<symbol> | C<symbol> | D<symbol> | E<symbol> | F<symbol> | G<symbol> | H<symbol> | I<symbol> | J<symbol> | K<symbol> | L<symbol> | M<symbol> | N<symbol> | O<symbol> | P<symbol> | Q<symbol> | R<symbol> | S<symbol> | T<symbol> | U<symbol> | V<symbol> | W<symbol> | X<symbol> | Y<symbol> | Z<symbol> | a<symbol> | b<symbol> | c<symbol> | d<symbol> | e<symbol> | f<symbol> | g<symbol> | h<symbol> | i<symbol> | j<symbol> | k<symbol> | l<symbol> | m<symbol> | n<symbol> | o<symbol> | p<symbol> | q<symbol> | r<symbol> | s<symbol> | t<symbol> | u<symbol> | v<symbol> | w<symbol> | x<symbol> | y<symbol> | z<symbol> | _<symbol>
<unicode_four> -> <unicode_character><unicode_character><unicode_character><unicode_character>
<unicode_five> -> <unicode_character><unicode_character><unicode_character><unicode_character><unicode_character>
<unicode character> -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F
<boolean> -> True | False
<logical_operation> -> not | and | or
<boolean_expressions> -> <boolean> | <Identifier> | <boolean_expressions> <logical_operation> <boolean_expressions> | <comparison_expressions>
<comparison_expressions> -> <mathematical_expressions> <comparison_operations <mathematical_expressions> | <String_expressions> <equivalence_operations><String_expressions>
<mathematical_expressions> -> <first_priority>
<first_priority> -> <second_priority> + <first_priority> | <second_priority> - <first_priority> | <second_priority>
<second_priority> -> <third_priority> * <second_priority> | <third_priority> / <second_priority> | <third_priority> % <second_priority> | <third_priority>
<third_priority> -> <fourth_priority> ** <third_priority> | <fourth_priority>
<fourth_priority> -> (<first_priority>) | <digit> | <Identifier> | <function_call> | <length_expressions>
<length_expressions> -> len ( <function_call> ) | len ( <Identifier> ) | len ( <collection> )
<String_expressions> -> <String> | <function_call> | <String> + <String_expressions> | <String_expressions> + <Identifier> | <Identifier> + <String_expressions> | <String_expressions> + <Identifier> + <String_expressions>
<concatenated_expressions> -> <String_expressions> | <mathematical_expressions> | <boolean_expressions> | <function_call> | <collection>
<left_expressions> -> <String_expressions> | <mathematical_expressions> | <boolean_expressions> | <function_call>
<function_call> -> <Identifier> ( <arguments> ) | <Identifier> ()
<output> -> print ( <concatenated_expressions> )
<assignment> -> <Identifier> = <concatenated_expressions>
<comparison_operations -> < | <= | > | >= | <equivalence_operations>
<equivalence_operations> -> != | ==
<simple_sentence> -> <sentence_body> newline | newline
<complex_sentence> -> <condition> | <cycle>
<sentence> -> <simple_sentence> | <complex_sentence>
<sentence_body> -> <concatenated_expressions> | <output> | <assignment> | pass | return <concatenated_expressions> | len(<function_call>)
<sentences> -> <sentence><sentences> | <sentence>
<block> -> <simple_sentence> | newline INDENT <sentences> DEDENT
<condition> -> if <boolean_expressions>: <block><otherwise> | if <boolean_expressions>: <block>
<otherwise> -> elif <condition> | else: <block>
<expressions> -> <concatenated_expressions>, <expressions> | <concatenated_expressions>
<simple_arguments> -> <expressions>
<named_expression> -> <assignment>, <named_expression> | <assignment>
<named_arguments> -> <named_expression>
<arguments> -> <simple_arguments> | <named_arguments>
<match> -> <left_expressions>: <concatenated_expressions>
<matches> -> <match>, <matches> | <match>
<collection> -> dict(<named_arguments>) | dict() | {<arguments>} | {<matches>} | {}
<cycle> -> <cycle> | <for_loop>
<cycle> -> while <boolean_expressions>: <block>
<for_loop> -> for <Identifier> in <collection>: <block>
<function> -> def <Identifier>(<Identifiers>): <block>